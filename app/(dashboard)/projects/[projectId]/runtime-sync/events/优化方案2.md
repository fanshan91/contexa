## 现状梳理（基于当前代码）
- `/runtime-sync/session` 实际渲染的是 [session/page.tsx](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/%5BprojectId%5D/runtime-sync/session/page.tsx) → `ProjectRuntimeSyncEventsClient`。
- 事件列表与路由概览目前复用同一个“路由维度”抽屉 `RuntimeSyncDrawer`（按 `route` 拉 `getRuntimeSessionRouteDiffQuery`），因此事件列表的“关联页面/模块”也会打开路由批处理抽屉。[runtime-events-client.tsx](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/%5BprojectId%5D/runtime-sync/events/runtime-events-client.tsx)
- 当 `diff.page == null` 时抽屉会用遮罩 + `pointer-events-none` 强阻断，必须先创建页面才能继续处理。[runtime-sync-drawer.tsx](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/%5BprojectId%5D/runtime-sync/runtime-sync-drawer.tsx#L417-L470)
- 草稿保存相关 action 当前是空实现（不落库），但 Prisma 已有 `RuntimeSessionDraftOp` 模型。[actions.ts](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/%5BprojectId%5D/runtime-sync/actions.ts#L1470-L1515) / [schema.prisma](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/prisma/schema.prisma#L291-L311)

## 目标（对应你提的 2 个痛点）
1) 路由未建页面时，“创建路由/页面”与“词条关联”解耦：创建是可选增强，不再阻断关联。
2) 明确区分“单事件管理”与“路由下多事件批处理”：事件列表点开就是单条 key 的快速关联；路由概览点开才进入批处理。

## 方案与实现步骤
### 1) 把抽屉按维度拆开（单事件 vs 路由批处理）
- 保留现有 `RuntimeSyncDrawer` 作为“路由批处理抽屉”。
- 新增一个“单事件抽屉”（建议新文件，避免继续膨胀 700+ 行的 client）：
  - 组件职责：展示该事件的 key/sourceText/attentionReason、选择目标页面/模块（`ContextNodePicker`）、可选创建页面/模块、保存草稿。
  - 不展示路由级 summary，不展示多条 diff 表格。
- 在 `ProjectRuntimeSyncEventsClient` 中区分两种打开方式：
  - 事件列表每行按钮 → 打开单事件抽屉（传入 `route + key + sourceText + 当前状态`）。
  - 路由概览每行按钮 → 打开路由批处理抽屉（传入 `route`）。

### 2) 解除“未建页面”强阻断（创建页面不再挡住关联）
- 修改 `RuntimeSyncDrawer` 在 `diff.page == null` 分支的 UI：
  - 移除遮罩与 `pointer-events-none`，表格仍可操作。
  - 顶部保留提示卡：当前路由未建页面，可“立即创建（推荐）/稍后创建”。
  - 因为缺少 `defaultNode`，当用户未为某条 key 选择目标时，默认行为是 `ignore`（与现在逻辑一致），但不会被迫先创建页面。

### 3) 让“草稿”真正可用，并把保存性能做成批量
- 实现当前两个 stub：
  - `listRuntimeSessionDraftOpsQuery`：从 `prisma.runtimeSessionDraftOp` 按 `projectId/sessionId/route?` 查询并返回。
  - `upsertRuntimeSessionDraftOpAction`：按 `@@unique([sessionId, route, key])` 做 upsert，写入 `action/targetPageId/targetModuleId/createdByUserId`。
- 增加一个新的 batch action（减少 N 次网络请求、提升体验）：
  - 例如 `upsertRuntimeSessionDraftOpsBatchAction({ projectId, sessionId, route, ops: [...] })`，事务内批量 upsert。
  - 前端 `onApply` 从 `Promise.all(map)` 改为一次 batch 调用。

### 4) 单事件的推荐交互（更“必要、简单、好用”）
- 事件列表每条提供“关联”动作：
  - 打开单事件抽屉 → 选择页面/模块 → “保存草稿并关闭”。
  - 同时提供一个不阻断的快捷入口：如果该 `route` 未建页面，显示“为此路由创建页面（可选）”。
- 事件列表增加一个轻量状态提示（不加复杂列）：
  - 已有 `attentionReason`，可以用 Badge/文案提示“缺失页面/未收录/未绑定/文案变更”。

### 5) 路由批处理的推荐交互（批处理更高效）
- 路由概览继续“查看/处理”进入路由批处理抽屉：
  - 支持一页内为多个 key 选择目标（现有能力保留）。
  - “保存草稿”变成真正落库（第 3 步完成后）。
- 可选第二阶段（我建议做）：在路由批处理抽屉里提供“应用到 TMS”按钮：
  - 直接调用现成的 `applyRuntimeDiffAction`（已接入 Enhanced）。[actions.ts](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/%5BprojectId%5D/runtime-sync/actions.ts#L930-L978)
  - 让开发者能在会话未结束时就把关系落地（减少“必须最后点保存”的心理负担）。

### 6) 页面级小优化（不加复杂度但更顺手）
- Tab 切换（事件列表/路由概览）保留各自搜索条件与分页（现在大体已分离，但可补齐一些边界：切换时不要触发不必要刷新）。
- 空态与提示更贴近操作点：
  - “仅差异为空”的 toast 改为在表格空态中给出可操作提示（关闭仅差异、清空筛选）。
- 自动刷新开关旁增加“为何被关闭/不可用”的轻提示（会话 stale 时）。

## 涉及文件（预计）
- 修改：
  - [runtime-events-client.tsx](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/%5BprojectId%5D/runtime-sync/events/runtime-events-client.tsx)（事件行操作改为单事件抽屉；路由行继续批处理抽屉；草稿保存改为 batch）
  - [runtime-sync-drawer.tsx](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/%5BprojectId%5D/runtime-sync/runtime-sync-drawer.tsx)（移除 diff.page==null 阻断；可选增加“应用到TMS”入口）
  - [actions.ts](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/%5BprojectId%5D/runtime-sync/actions.ts)（实现 draft ops 查询/写入；新增 batch upsert）
- 新增（必要时）：`runtime-sync/runtime-sync-event-drawer.tsx`（单事件抽屉组件，避免继续膨胀 client 文件）。

## 验证方式（待你确认后执行）
- 类型检查：确保新增 action/组件无 TS 报错。
- 手工验证路径：
  - 事件列表：对任意 key 执行“关联”→ 保存草稿 → 刷新页面后草稿仍在。
  - 路由未建页面：不创建页面也能完成 key 关联草稿。
  - 路由批处理：保存草稿一次请求完成；可选“应用到TMS”成功后事件/路由统计刷新。

如果你确认，我就按上述顺序开始改代码，把交互拆清晰并把草