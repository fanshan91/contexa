# Runtime Sync 采集会话页面 UX 优化 — 代码调整方案

## 两方案评审结论

**方案 1**（优化方案1.md）侧重问题分析与优先级梳理，列出 7 项优化并给出优先级排序，思路全面但代码方案只给了方向。

**方案 2**（优化方案2.md）更面向实施，把改动按步骤拆分到具体文件和函数，并补充了草稿落库 + 批量 upsert + 单事件抽屉等具体实施路径。

**推荐：以方案 2 为主干，融合方案 1 中的 P1/P2 体验打磨项（视图切换数字、筛选器 debounce、分页增强），形成最终方案。** 项目未上线，数据库可调整，不需要兼容旧数据，因此采取最优结构。

---

## 改动文件清单

| 文件 | 操作 | 主要改动 |
|------|------|----------|
| [actions.ts](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/[projectId]/runtime-sync/actions.ts) | MODIFY | 实现 draft ops 查询/写入 + 新增 batch upsert |
| [runtime-sync-drawer.tsx](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/[projectId]/runtime-sync/runtime-sync-drawer.tsx) | MODIFY | 移除强阻断遮罩 |
| [runtime-sync-event-drawer.tsx](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/[projectId]/runtime-sync/runtime-sync-event-drawer.tsx) | NEW | 单事件抽屉组件 |
| [runtime-events-client.tsx](file:///Users/nihao/Desktop/project/products/TMS/contexa/apps/web/app/(dashboard)/projects/[projectId]/runtime-sync/events/runtime-events-client.tsx) | MODIFY | 区分两种抽屉入口 + batch 调用 + 体验打磨 |

---

## 1. Prisma Schema — 无需改动

`RuntimeSessionDraftOp` 模型已存在且结构完备：

```
@@unique([sessionId, route, key])
@@index([projectId, sessionId])
```

字段 `action`/`targetPageId`/`targetModuleId`/`createdByUserId` 足以支撑全部需求，无需迁移。

---

## 2. Server Actions — actions.ts

### 2a. 实现 `listRuntimeSessionDraftOpsQuery`（L1478-1493）

当前为 stub，始终返回空数组。改为真实查询：

```diff
 export async function listRuntimeSessionDraftOpsQuery(input: {
   projectId: number;
   sessionId: number;
   route?: string;
 }): Promise<{ ok: true; data: RuntimeSessionDraftOpRow[] } | { ok: false; error: string }> {
   try {
     const parsed = z.object({
       projectId: z.number().int().positive(),
+      sessionId: z.number().int().positive(),
+      route: z.string().trim().min(1).max(200).optional()
     }).safeParse(input);
     if (!parsed.success) return { ok: false, error: parsed.error.errors[0].message };
     await getProjectPermissionChecker(parsed.data.projectId);
-    return { ok: true, data: [] as RuntimeSessionDraftOpRow[] };
+
+    const where: any = {
+      projectId: parsed.data.projectId,
+      sessionId: parsed.data.sessionId
+    };
+    if (parsed.data.route) where.route = parsed.data.route;
+
+    const rows = await prisma.runtimeSessionDraftOp.findMany({
+      where,
+      orderBy: { updatedAt: 'desc' },
+      select: { route: true, key: true, action: true, targetPageId: true, targetModuleId: true }
+    });
+    return {
+      ok: true,
+      data: rows.map((r) => ({
+        route: r.route,
+        key: r.key,
+        action: r.action as RuntimeSessionDraftOpRow['action'],
+        targetPageId: r.targetPageId,
+        targetModuleId: r.targetModuleId
+      }))
+    };
   } catch (error) { ... }
 }
```

### 2b. 实现 `upsertRuntimeSessionDraftOpAction`（L1495-1515）

当前为 stub。改为真实 upsert：

```diff
 export async function upsertRuntimeSessionDraftOpAction(input: {
   projectId: number;
   sessionId: number;
   route: string;
   key: string;
   action: 'ignore' | 'bind' | 'delete';
   targetPageId?: number | null;
   targetModuleId?: number | null;
 }): Promise<{ ok: true } | { ok: false; error: string }> {
   try {
-    const parsed = z.object({ projectId: z.number().int().positive() }).safeParse(input);
+    const parsed = z.object({
+      projectId: z.number().int().positive(),
+      sessionId: z.number().int().positive(),
+      route: z.string().trim().min(1).max(200),
+      key: z.string().trim().min(1).max(200),
+      action: z.enum(['ignore', 'bind', 'delete']),
+      targetPageId: z.number().int().positive().nullable().optional(),
+      targetModuleId: z.number().int().positive().nullable().optional()
+    }).safeParse(input);
     if (!parsed.success) return { ok: false, error: parsed.error.errors[0].message };
-    const { can } = await getProjectPermissionChecker(parsed.data.projectId, true);
+    const { user, can } = await getProjectPermissionChecker(parsed.data.projectId, true);
     if (!can(['admin', 'creator'])) return { ok: false, error: '无权限执行保存操作' };
-    return { ok: true };
+
+    await prisma.runtimeSessionDraftOp.upsert({
+      where: {
+        sessionId_route_key: {
+          sessionId: parsed.data.sessionId,
+          route: parsed.data.route,
+          key: parsed.data.key
+        }
+      },
+      update: {
+        action: parsed.data.action,
+        targetPageId: parsed.data.targetPageId ?? null,
+        targetModuleId: parsed.data.targetModuleId ?? null,
+        createdByUserId: user.id
+      },
+      create: {
+        projectId: parsed.data.projectId,
+        sessionId: parsed.data.sessionId,
+        route: parsed.data.route,
+        key: parsed.data.key,
+        action: parsed.data.action,
+        targetPageId: parsed.data.targetPageId ?? null,
+        targetModuleId: parsed.data.targetModuleId ?? null,
+        createdByUserId: user.id
+      }
+    });
+    return { ok: true };
   } catch (error) { ... }
 }
```

### 2c. 新增 `upsertRuntimeSessionDraftOpsBatchAction`

在 `upsertRuntimeSessionDraftOpAction` 之后新增批量版本，替代前端 `Promise.all(ops.map(...))`：

```typescript
export async function upsertRuntimeSessionDraftOpsBatchAction(input: {
  projectId: number;
  sessionId: number;
  route: string;
  ops: Array<{
    key: string;
    action: 'ignore' | 'bind' | 'delete';
    targetPageId?: number | null;
    targetModuleId?: number | null;
  }>;
}): Promise<{ ok: true } | { ok: false; error: string }> {
  try {
    const parsed = z.object({
      projectId: z.number().int().positive(),
      sessionId: z.number().int().positive(),
      route: z.string().trim().min(1).max(200),
      ops: z.array(z.object({
        key: z.string().trim().min(1).max(200),
        action: z.enum(['ignore', 'bind', 'delete']),
        targetPageId: z.number().int().positive().nullable().optional(),
        targetModuleId: z.number().int().positive().nullable().optional()
      })).max(2000)
    }).safeParse(input);
    if (!parsed.success) return { ok: false, error: parsed.error.errors[0].message };

    const { user, can } = await getProjectPermissionChecker(parsed.data.projectId, true);
    if (!can(['admin', 'creator'])) return { ok: false, error: '无权限执行保存操作' };

    await prisma.$transaction(
      parsed.data.ops.map((op) =>
        prisma.runtimeSessionDraftOp.upsert({
          where: {
            sessionId_route_key: {
              sessionId: parsed.data.sessionId,
              route: parsed.data.route,
              key: op.key
            }
          },
          update: {
            action: op.action,
            targetPageId: op.targetPageId ?? null,
            targetModuleId: op.targetModuleId ?? null,
            createdByUserId: user.id
          },
          create: {
            projectId: parsed.data.projectId,
            sessionId: parsed.data.sessionId,
            route: parsed.data.route,
            key: op.key,
            action: op.action,
            targetPageId: op.targetPageId ?? null,
            targetModuleId: op.targetModuleId ?? null,
            createdByUserId: user.id
          }
        })
      )
    );
    return { ok: true };
  } catch (error) {
    const debugId = crypto.randomUUID();
    console.error('runtimeSync batch upsert draft ops failed', { debugId, input }, error);
    return { ok: false, error: `保存失败 (debugId: ${debugId})` };
  }
}
```

---

## 3. Drawer 组件 — 解除强阻断

### [MODIFY] runtime-sync-drawer.tsx

**改动范围：L417-470**（`diff.page === null` 分支）

**当前问题**：整个 diff 表用 `opacity-60 grayscale pointer-events-none` + backdrop-blur 遮罩，用户完全无法与数据交互。

**改为**：

1. 保留顶部**创建页面**的提示 `Alert`（已有，不改）
2. **移除遮罩 + pointer-events-none**，diff 表格正常可操作
3. `ContextNodePicker` 的 `disabled` 判断中去掉 `pages.length === 0`，改为仅保留 `!canManage`
4. 当 `diff.page === null` 时，`defaultNode` 已经是 `null`（L130-134），用户必须手动选择目标 → 未选 = `action: ignore`（逻辑正确）

```diff
        ) : (
          <div className="flex flex-col gap-4 flex-1 overflow-hidden">
            <Alert ... /> {/* 保留创建页面提示，不变 */}

-           <div className="flex-1 overflow-auto rounded-md border opacity-60 grayscale-[0.5] pointer-events-none select-none relative">
-              <div className="absolute inset-0 z-10 flex items-center justify-center bg-background/10 backdrop-blur-[1px]">
-                <span className="bg-background/80 px-4 py-2 rounded-full border shadow-sm text-sm font-medium">请先创建页面</span>
-              </div>
+           <div className="flex-1 overflow-auto rounded-md border">
              <Table
                columns={columns}
                data={diff.items}
                rowKey={(r: any) => r.key}
                emptyText="暂无差异项。"
              />
            </div>
          </div>
        )}
```

同时修改 `ContextNodePicker` 的 `disabled` 属性（L226）：

```diff
-   disabled={!canManage || pages.length === 0}
+   disabled={!canManage}
```

---

## 4. 新增单事件抽屉

### [NEW] runtime-sync-event-drawer.tsx

新文件，约 180 行。职责：

- 展示单条事件的 `key` / `sourceText` / `attentionReason`
- 内嵌 `ContextNodePicker` 让用户选择目标页面/模块
- 若路由无页面，内联显示「为此路由创建页面（可选）」
- 底部「保存草稿」按钮，调用 `upsertRuntimeSessionDraftOpAction`

```typescript
// 关键 Props
type RuntimeSyncEventDrawerProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  projectId: number;
  event: {
    route: string;
    key: string;
    sourceText: string;
    entrySourceText: string | null;
    attentionReason: string;
    pageId: number | null;
    moduleId: number | null;
  } | null;
  contextPages: ContextPageNode[];
  canManage: boolean;
  onSaveDraft: (op: {
    route: string;
    key: string;
    action: 'ignore' | 'bind' | 'delete';
    targetPageId: number | null;
    targetModuleId: number | null;
  }) => Promise<any>;
  onCreatePage: (input: {
    projectId: number;
    route: string;
    title?: string;
    moduleName?: string;
  }) => Promise<any>;
  onCreateModule: (input: {
    projectId: number;
    pageId: number;
    name: string;
  }) => Promise<any>;
};
```

组件核心结构：

```tsx
export function RuntimeSyncEventDrawer({ ... }: RuntimeSyncEventDrawerProps) {
  const [selected, setSelected] = useState<SelectedNode | null>(null);
  const [newPageTitle, setNewPageTitle] = useState('');
  const [newModuleName, setNewModuleName] = useState('');
  const [pending, startTransition] = useTransition();

  // 打开时设置默认值（若已有 pageId/moduleId）
  useEffect(() => {
    if (!open || !event) return;
    if (event.moduleId && event.pageId) {
      setSelected({ type: 'module', pageId: event.pageId, moduleId: event.moduleId });
    } else if (event.pageId) {
      setSelected({ type: 'page', pageId: event.pageId });
    } else {
      setSelected(null);
    }
    setNewPageTitle('');
    setNewModuleName('');
  }, [open, event]);

  const pages = useMemo(() => toContextPages(projectId, contextPages), [projectId, contextPages]);
  const hasMatchingPage = contextPages.some((p) => p.route === event?.route);

  const save = () => {
    if (!event) return;
    startTransition(async () => {
      await onSaveDraft({
        route: event.route,
        key: event.key,
        action: selected ? 'bind' : 'ignore',
        targetPageId: selected?.pageId ?? null,
        targetModuleId: selected?.type === 'module' ? selected.moduleId : null
      });
    });
  };

  return (
    <Sheet open={open} onOpenChange={onOpenChange}
      title="单条词条关联"
      contentClassName="max-w-[600px]"
      footer={
        <div className="flex items-center justify-end gap-2 py-2">
          <Button variant="outline" onClick={() => onOpenChange(false)}>取消</Button>
          <Button onClick={save} disabled={!canManage || pending}>保存草稿</Button>
        </div>
      }
    >
      <div className="flex flex-col gap-4 py-4">
        {/* 事件信息区 */}
        <div className="rounded-lg border bg-muted/40 p-4 space-y-2">
          <div className="flex items-center gap-2 text-sm">
            <span className="text-muted-foreground">路由</span>
            <code className="...">{event?.route}</code>
          </div>
          <div className="flex items-center gap-2 text-sm">
            <span className="text-muted-foreground">Key</span>
            <code className="...">{event?.key}</code>
          </div>
          <div className="text-sm">
            <span className="text-muted-foreground">采集文案：</span>
            {event?.sourceText}
          </div>
          {event?.attentionReason !== 'ok' && (
            <Badge variant="warning">{attentionLabel}</Badge>
          )}
        </div>

        {/* 目标选择 */}
        <div className="space-y-2">
          <div className="text-sm font-medium">关联到页面/模块</div>
          <ContextNodePicker
            pages={pages}
            selected={selected}
            onSelect={setSelected}
            disabled={!canManage}
          />
        </div>

        {/* 路由无页面时的快捷创建区 */}
        {!hasMatchingPage && (
          <Alert variant="warning" title="当前路由未关联页面">
            <div className="flex gap-2 mt-2">
              <Input value={newPageTitle} onChange={...} placeholder="页面标题" />
              <Button onClick={createPage}>创建页面</Button>
            </div>
          </Alert>
        )}
      </div>
    </Sheet>
  );
}
```

---

## 5. Events Client — 区分两种抽屉 + 体验打磨

### [MODIFY] runtime-events-client.tsx

#### 5a. 新增单事件抽屉 state + import

```diff
+ import { RuntimeSyncEventDrawer } from '../runtime-sync-event-drawer';
+ import { upsertRuntimeSessionDraftOpsBatchAction } from '../actions';

  // 新增 state
+ const [eventDrawerOpen, setEventDrawerOpen] = useState(false);
+ const [eventDrawerEvent, setEventDrawerEvent] = useState<{
+   route: string; key: string; sourceText: string;
+   entrySourceText: string | null; attentionReason: string;
+   pageId: number | null; moduleId: number | null;
+ } | null>(null);
```

#### 5b. 事件列表 columns — 操作列改为打开单事件抽屉

```diff
  // columns 中 actions 列（L279-294）
  render: (_: unknown, record: any) => (
    <div className="flex flex-wrap gap-2">
      <Button
        variant="outline" size="sm" className="shadow-none"
        disabled={!canReadEnhanced}
        onClick={() => {
-         setDrawerRoute(record.route);
-         setDrawerOpen(true);
+         setEventDrawerEvent({
+           route: record.route,
+           key: record.key,
+           sourceText: record.sourceText,
+           entrySourceText: record.entrySourceText,
+           attentionReason: record.attentionReason,
+           pageId: record.pageId,
+           moduleId: record.moduleId
+         });
+         setEventDrawerOpen(true);
        }}
      >
        关联页面/模块
      </Button>
    </div>
  )
```

#### 5c. 路由概览操作列保持不变

路由概览的 routeColumns 中 `actions` 列（L353-366）保持现有行为不变，仍然打开路由级批量抽屉。

#### 5d. 预加载 contextPages

将 `contextPages` 的加载从打开抽屉时提前到组件 mount 时：

```diff
+ // 组件 mount 时预加载 contextPages
+ useEffect(() => {
+   startTransition(async () => {
+     const nodes = await listRuntimeContextNodesQuery(projectId);
+     if (nodes.ok) setContextPages(nodes.data.pages);
+   });
+ }, [projectId]);
```

#### 5e. 路由批处理抽屉 onApply 改用 batch action

```diff
  // 替换 onApply 中的 Promise.all(ops.map(...))
  onApply={async (ops) => {
    if (!viewSessionId || !hasActiveSession) return { ok: false, error: 'no_active_session' };
-   const results = await Promise.all(
-     ops.map((op) =>
-       upsertRuntimeSessionDraftOpAction({ ... })
-     )
-   );
-   const failed = results.find((r) => !r.ok);
-   if (failed) {
-     push({ variant: 'destructive', title: '保存草稿失败', message: (failed as any).error ?? '请求失败' });
-     return failed as any;
-   }
+   const res = await upsertRuntimeSessionDraftOpsBatchAction({
+     projectId,
+     sessionId: viewSessionId,
+     route: drawerRoute,
+     ops: ops.map((op) => ({
+       key: op.key,
+       action: op.action,
+       targetPageId: op.targetPageId ?? null,
+       targetModuleId: op.targetModuleId ?? null
+     }))
+   });
+   if (!res.ok) {
+     push({ variant: 'destructive', title: '保存草稿失败', message: res.error });
+     return res;
+   }
    push({ variant: 'default', message: '草稿已保存' });
    refreshDrawer();
    refreshEvents();
    return { ok: true };
  }}
```

#### 5f. JSX — 添加单事件抽屉

在现有 `<RuntimeSyncDrawer ... />` 下方增加：

```tsx
<RuntimeSyncEventDrawer
  open={eventDrawerOpen}
  onOpenChange={setEventDrawerOpen}
  projectId={projectId}
  event={eventDrawerEvent}
  contextPages={contextPages}
  canManage={canMutate}
  onSaveDraft={async (op) => {
    if (!viewSessionId || !hasActiveSession) return { ok: false, error: 'no_active_session' };
    const res = await upsertRuntimeSessionDraftOpAction({
      projectId,
      sessionId: viewSessionId,
      route: op.route,
      key: op.key,
      action: op.action,
      targetPageId: op.targetPageId,
      targetModuleId: op.targetModuleId
    });
    if (!res.ok) {
      push({ variant: 'destructive', title: '保存草稿失败', message: (res as any).error ?? '请求失败' });
      return res;
    }
    push({ variant: 'default', message: '草稿已保存' });
    setEventDrawerOpen(false);
    refreshEvents();
    return { ok: true };
  }}
  onCreatePage={async (payload) => {
    const res = await createRuntimePageAction(payload);
    if (res.ok) {
      const nodes = await listRuntimeContextNodesQuery(projectId);
      if (nodes.ok) setContextPages(nodes.data.pages);
    }
    return res;
  }}
  onCreateModule={async (payload) => {
    const res = await createRuntimeModuleAction(payload);
    if (res.ok) {
      const nodes = await listRuntimeContextNodesQuery(projectId);
      if (nodes.ok) setContextPages(nodes.data.pages);
    }
    return res;
  }}
/>
```

#### 5g. 体验打磨（融合方案 1 的 P1/P2 项）

**① 视图切换附加数字**（约 L547-561）：

```diff
- 事件列表
+ 事件列表 ({events.total})
- 路由概览
+ 路由概览 ({routeStats.total})
```

**② 搜索框 debounce**（事件搜索 L624-635）：

增加 `useEffect` + `setTimeout` 300ms debounce，`search` 变化后自动调用 `refreshEvents({ page: 1 })`，移除手动按回车搜索的依赖：

```typescript
useEffect(() => {
  if (!viewSessionId) return;
  if (viewMode !== 'events') return;
  const timer = setTimeout(() => {
    refreshEvents({ page: 1 });
  }, 300);
  return () => clearTimeout(timer);
}, [search]);
```

**③ 分页增加 pageSize 选择器**（约 L662-685）：

增加 `<Select>` 让用户选择 20 / 50 / 100 条每页，路由概览同理：

```tsx
<Select
  value={String(events.pageSize)}
  onValueChange={(v) => {
    const newSize = Number(v);
    setEvents((prev) => ({ ...prev, pageSize: newSize }));
    refreshEvents({ page: 1 });
  }}
  options={[
    { value: '20', label: '20 条/页' },
    { value: '50', label: '50 条/页' },
    { value: '100', label: '100 条/页' }
  ]}
  className="h-9 w-[120px]"
/>
```

---

## 验证计划

### TypeScript 类型检查

```bash
cd /Users/nihao/Desktop/project/products/TMS/contexa && npx tsc --noEmit
```

### 手动验证

1. `npm run dev` 启动本地开发
2. 进入 `/projects/[id]/runtime-sync/session`，确保有活跃采集会话
3. **验证单事件抽屉**：在事件列表点击任意行的「关联页面/模块」→ 应打开轻量单事件抽屉（非路由批处理抽屉）→ 选择页面/模块 → 保存草稿 → 刷新页面后草稿仍在
4. **验证路由批处理抽屉**：切换到路由概览 → 点击「查看/处理」→ 应打开现有路由级抽屉 → 保存草稿通过 batch action 一次完成
5. **验证无页面场景**：找一个尚未创建页面的路由 → 打开抽屉/单事件抽屉 → 应无遮罩，可正常操作 ContextNodePicker → 可选创建页面
6. **验证视图数字**：检查事件列表/路由概览切换按钮上有数字显示
7. **验证搜索 debounce**：在搜索框输入文字后等待 300ms，应自动刷新，无需按回车
